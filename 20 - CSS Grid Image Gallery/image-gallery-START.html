<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>CSS Grid Image Gallery!</title>
</head>

<body>

  <div class="overlay">
    <div class="overlay-inner">
      <button class="close">× Close</button>
      <img>
    </div>
  </div>

  <section class="gallery">
  </section>


  <style>
    * {
      box-sizing: border-box;
    }

    body {
      padding: 50px;
      font-family: sans-serif;
      background: linear-gradient(to right, #F93D66, #6D47D9);
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0 0 5px 0;
    }

    p {
      margin: 0 0 20px 0;
    }

    .close {
      background: none;
      color: white;
      border: 0;
    }

    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, 100px);
      /* we'll size the implicit rows with 100px */
      grid-auto-rows: 100px;
      /* By default, if gaps are created in the grid when placing items, auto-positioned grid items will not fill the gaps, 
      but instead will be added after the last item. 
      We can change that with the dense keyword, which tells the implicit 
      grid algorithm to try and go back and fill the gaps with the auto-placed items, changing the order of items when needed: */
      grid-auto-flow: dense;
    }

    .item {
      display: grid;
      overflow: hidden;
      grid-template-columns: 1;
      grid-template-rows: 1;
    }

    .item.v2 {
      grid-row: span 2;
    }
    .item.v3 {
      grid-row: span 3;
    }
    .item.v4 {
      grid-row: span 4;
    }
    
    .item.h2 {
      grid-column: span 2;
    }
    .item.h3 {
      grid-column: span 3;
    }
    .item.h4 {
      grid-column: span 4;
    }



    .overlay {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      display: none;
      z-index: 2;
    }

    .overlay.open {
      display: grid;
    }

    .overlay figure {
      background: white;
      width: 700px;
      padding: 20px;
    }

    .overlay img {
      width: 100%;
    }
  </style>

  <script>
    const gallery = document.querySelector(".gallery");
    const overlay = document.querySelector(".overlay");
    const overlayImage = document.querySelector("img");
    const overlayClose = document.querySelector(".close");

    /* destructoring in the argument for the horizontal and vertical values*/
    function generateHTML([h, v]) {
      return `
        <div class="item h${h} v${v}">
          <img src="images/${randomNumber(12)}.jpg">
          <div class="item__overlay">
            <button>View →</button>
          </div>
        </div>
      `;
    }

    function randomNumber(limit) {
      return Math.floor(Math.random() * limit) + 1;
    }

    /*we can make an empty array with 50 blank spots by 
    using Array.from and passing it an object with a length property of 50 
    Array.from also takes a map funct which allows us to populate what goes into each spot*/
    const digits = Array.from({ length: 50}, () => [randomNumber(4), randomNumber(4)]);
    
    /*html === array
    it takes the indiv digits pairs from the digits array 
    uses generateHTML as the callback
    generateHTML destructures the two numbers and generates the necessary html */
    const html = digits.map(generateHTML).join('');
    gallery.innerHTML = html;

    /*So we have 50 divs with classes of item and we reload,
    they will all be different */
    console.log(html);

  </script>
</body>

</html>